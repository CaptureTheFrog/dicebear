{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DiceBear Py Wrapper \\ dicebear is an API wrapper for https://dicebear.com. Using this wrapper you can get custom avatars for your program. \\ For an example go to examples/dicebear.py . Useful links PyPI: https://pypi.org/project/dicebear/ GitHub: https://github.com/jvherck/dicebear Dicebear: https://dicebear.com Dicebear CLI: https://github.com/jvherck/dicebear-cli How to install Run pip install dicebear \\ If that doesn't work try py -m pip install dicebear Usage Important note: Pillow is not a required dependency, it's only required when you want to be able to edit the avatar images (using DAvatar.pillow() ). When using a PIL function while it's not installed it will raise dicebear.errors.PILError . from dicebear import DAvatar , DStyle , DOptions , DColor options = DOptions ( backgroundColor = DColor ( \"#00ddd0\" ), rotate = 90 ) av = DAvatar ( style = DStyle . pixel_art , seed = \"John Apple\" , options = options ) print ( av . url_svg ) av . edit ( extra_options = DOptions ( backgroundColor = DColor ( \"#000000\" ) ) ) # This will keep the `rotate` option but override the `backgroundColor` option print ( av . url_png ) av . edit_specific ( blank_options = { \"face\" : \"variant04\" } ) # This edits the style specific options print ( av . url_png ) image : PIL . Image . Image = av . pillow () # converts the DAvatar into a Pillow Image object CLI Usage Since version 0.4.0 there's a CLI for DiceBear. It can quickly create one or more avatars at a time but it can't take options. To use the CLI go to https://github.com/jvherck/dicebear-cli and use pip install dicebear-cli to install the CLI Styles All the possible avatar styles. \\ https://avatars.dicebear.com/styles adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral Base Options All the possible options for the avatar. These options work for all the styles. seed (type: str ) - the seed for the avatar generator, determine its basic looks dataUri (type: bool ) - whether to give the dataUri (default False) flip (type: bool ) - flips the image vertically (default False) rotate (type: int ) - rotates the avatar (default 0, min 0, max 360) scale (type: int ) - the scale of the avatar drawing itself (default 100, min 0, max 200) radius (type: int ) - the radius of the avatar (default 0, min 0, max 50) size (type: int ) - the size of the avatar (px) (default 256, min 1, max 256) backgroundColor (type: DColor( \" #ffffff \" ) ) - the background color of the avatar (default white) translateX (type: int ) - move the avatar horizontally (default 0, min -100, max 100) translateY (type: int ) - move the avatar vertically (default 0, min -100, max 100) Specific Style Options Specific options to get a more detailed avatar. This is different for every style. \\ Click the style to see its options. adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral Formats These are the only supported formats. \\ If you have Pillow (PIL) installed you can convert DAvatar to a PIL.Image.Image object to get a wider range of formats (Pillow doesn't support svg). DFormat.png DFormat.svg Credits Special thanks to DiceBear ( Florian K\u00f6rner ) for making this amazing API and to all artists that helped making avatars! Licenses and privacy policy Dicebear Licenses : https://avatars.dicebear.com/licenses Dicebear Privacy Policy : https://avatars.dicebear.com/legal/privacy-policy Dicebear Python API wrapper (this project): https://github.com/jvherck/dicebear/blob/main/LICENSE","title":"Home"},{"location":"#dicebear-py-wrapper","text":"\\ dicebear is an API wrapper for https://dicebear.com. Using this wrapper you can get custom avatars for your program. \\ For an example go to examples/dicebear.py .","title":"DiceBear Py Wrapper"},{"location":"#useful-links","text":"PyPI: https://pypi.org/project/dicebear/ GitHub: https://github.com/jvherck/dicebear Dicebear: https://dicebear.com Dicebear CLI: https://github.com/jvherck/dicebear-cli","title":"Useful links"},{"location":"#how-to-install","text":"Run pip install dicebear \\ If that doesn't work try py -m pip install dicebear","title":"How to install"},{"location":"#usage","text":"Important note: Pillow is not a required dependency, it's only required when you want to be able to edit the avatar images (using DAvatar.pillow() ). When using a PIL function while it's not installed it will raise dicebear.errors.PILError . from dicebear import DAvatar , DStyle , DOptions , DColor options = DOptions ( backgroundColor = DColor ( \"#00ddd0\" ), rotate = 90 ) av = DAvatar ( style = DStyle . pixel_art , seed = \"John Apple\" , options = options ) print ( av . url_svg ) av . edit ( extra_options = DOptions ( backgroundColor = DColor ( \"#000000\" ) ) ) # This will keep the `rotate` option but override the `backgroundColor` option print ( av . url_png ) av . edit_specific ( blank_options = { \"face\" : \"variant04\" } ) # This edits the style specific options print ( av . url_png ) image : PIL . Image . Image = av . pillow () # converts the DAvatar into a Pillow Image object","title":"Usage"},{"location":"#cli-usage","text":"Since version 0.4.0 there's a CLI for DiceBear. It can quickly create one or more avatars at a time but it can't take options. To use the CLI go to https://github.com/jvherck/dicebear-cli and use pip install dicebear-cli to install the CLI","title":"CLI Usage"},{"location":"#styles","text":"All the possible avatar styles. \\ https://avatars.dicebear.com/styles adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral","title":"Styles"},{"location":"#base-options","text":"All the possible options for the avatar. These options work for all the styles. seed (type: str ) - the seed for the avatar generator, determine its basic looks dataUri (type: bool ) - whether to give the dataUri (default False) flip (type: bool ) - flips the image vertically (default False) rotate (type: int ) - rotates the avatar (default 0, min 0, max 360) scale (type: int ) - the scale of the avatar drawing itself (default 100, min 0, max 200) radius (type: int ) - the radius of the avatar (default 0, min 0, max 50) size (type: int ) - the size of the avatar (px) (default 256, min 1, max 256) backgroundColor (type: DColor( \" #ffffff \" ) ) - the background color of the avatar (default white) translateX (type: int ) - move the avatar horizontally (default 0, min -100, max 100) translateY (type: int ) - move the avatar vertically (default 0, min -100, max 100)","title":"Base Options"},{"location":"#specific-style-options","text":"Specific options to get a more detailed avatar. This is different for every style. \\ Click the style to see its options. adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral","title":"Specific Style Options"},{"location":"#formats","text":"These are the only supported formats. \\ If you have Pillow (PIL) installed you can convert DAvatar to a PIL.Image.Image object to get a wider range of formats (Pillow doesn't support svg). DFormat.png DFormat.svg","title":"Formats"},{"location":"#credits","text":"Special thanks to DiceBear ( Florian K\u00f6rner ) for making this amazing API and to all artists that helped making avatars!","title":"Credits"},{"location":"#licenses-and-privacy-policy","text":"Dicebear Licenses : https://avatars.dicebear.com/licenses Dicebear Privacy Policy : https://avatars.dicebear.com/legal/privacy-policy Dicebear Python API wrapper (this project): https://github.com/jvherck/dicebear/blob/main/LICENSE","title":"Licenses and privacy policy"},{"location":"docs/","text":"DiceBear Py Wrapper \\ dicebear is an API wrapper for https://dicebear.com. Using this wrapper you can get custom avatars for your program. \\ For an example go to examples/dicebear.py . Useful links PyPI: https://pypi.org/project/dicebear/ GitHub: https://github.com/jvherck/dicebear Dicebear: https://dicebear.com Dicebear CLI: https://github.com/jvherck/dicebear-cli How to install Run pip install dicebear \\ If that doesn't work try py -m pip install dicebear Usage Important note: Pillow is not a required dependency, it's only required when you want to be able to edit the avatar images (using DAvatar.pillow() ). When using a PIL function while it's not installed it will raise dicebear.errors.PILError . from dicebear import DAvatar , DStyle , DOptions , DColor options = DOptions ( backgroundColor = DColor ( \"#00ddd0\" ), rotate = 90 ) av = DAvatar ( style = DStyle . pixel_art , seed = \"John Apple\" , options = options ) print ( av . url_svg ) av . edit ( extra_options = DOptions ( backgroundColor = DColor ( \"#000000\" ) ) ) # This will keep the `rotate` option but override the `backgroundColor` option print ( av . url_png ) av . edit_specific ( blank_options = { \"face\" : \"variant04\" } ) # This edits the style specific options print ( av . url_png ) image : PIL . Image . Image = av . pillow () # converts the DAvatar into a Pillow Image object CLI Usage Since version 0.4.0 there's a CLI for DiceBear. It can quickly create one or more avatars at a time but it can't take options. To use the CLI go to https://github.com/jvherck/dicebear-cli and use pip install dicebear-cli to install the CLI Styles All the possible avatar styles. \\ https://avatars.dicebear.com/styles adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral Base Options All the possible options for the avatar. These options work for all the styles. seed (type: str ) - the seed for the avatar generator, determine its basic looks dataUri (type: bool ) - whether to give the dataUri (default False) flip (type: bool ) - flips the image vertically (default False) rotate (type: int ) - rotates the avatar (default 0, min 0, max 360) scale (type: int ) - the scale of the avatar drawing itself (default 100, min 0, max 200) radius (type: int ) - the radius of the avatar (default 0, min 0, max 50) size (type: int ) - the size of the avatar (px) (default 256, min 1, max 256) backgroundColor (type: DColor( \" #ffffff \" ) ) - the background color of the avatar (default white) translateX (type: int ) - move the avatar horizontally (default 0, min -100, max 100) translateY (type: int ) - move the avatar vertically (default 0, min -100, max 100) Specific Style Options Specific options to get a more detailed avatar. This is different for every style. \\ Click the style to see its options. adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral Formats These are the only supported formats. \\ If you have Pillow (PIL) installed you can convert DAvatar to a PIL.Image.Image object to get a wider range of formats (Pillow doesn't support svg). DFormat.png DFormat.svg Credits Special thanks to DiceBear ( Florian K\u00f6rner ) for making this amazing API and to all artists that helped making avatars! Licenses and privacy policy Dicebear Licenses : https://avatars.dicebear.com/licenses Dicebear Privacy Policy : https://avatars.dicebear.com/legal/privacy-policy Dicebear Python API wrapper (this project): https://github.com/jvherck/dicebear/blob/main/LICENSE","title":"Readme"},{"location":"docs/#dicebear-py-wrapper","text":"\\ dicebear is an API wrapper for https://dicebear.com. Using this wrapper you can get custom avatars for your program. \\ For an example go to examples/dicebear.py .","title":"DiceBear Py Wrapper"},{"location":"docs/#useful-links","text":"PyPI: https://pypi.org/project/dicebear/ GitHub: https://github.com/jvherck/dicebear Dicebear: https://dicebear.com Dicebear CLI: https://github.com/jvherck/dicebear-cli","title":"Useful links"},{"location":"docs/#how-to-install","text":"Run pip install dicebear \\ If that doesn't work try py -m pip install dicebear","title":"How to install"},{"location":"docs/#usage","text":"Important note: Pillow is not a required dependency, it's only required when you want to be able to edit the avatar images (using DAvatar.pillow() ). When using a PIL function while it's not installed it will raise dicebear.errors.PILError . from dicebear import DAvatar , DStyle , DOptions , DColor options = DOptions ( backgroundColor = DColor ( \"#00ddd0\" ), rotate = 90 ) av = DAvatar ( style = DStyle . pixel_art , seed = \"John Apple\" , options = options ) print ( av . url_svg ) av . edit ( extra_options = DOptions ( backgroundColor = DColor ( \"#000000\" ) ) ) # This will keep the `rotate` option but override the `backgroundColor` option print ( av . url_png ) av . edit_specific ( blank_options = { \"face\" : \"variant04\" } ) # This edits the style specific options print ( av . url_png ) image : PIL . Image . Image = av . pillow () # converts the DAvatar into a Pillow Image object","title":"Usage"},{"location":"docs/#cli-usage","text":"Since version 0.4.0 there's a CLI for DiceBear. It can quickly create one or more avatars at a time but it can't take options. To use the CLI go to https://github.com/jvherck/dicebear-cli and use pip install dicebear-cli to install the CLI","title":"CLI Usage"},{"location":"docs/#styles","text":"All the possible avatar styles. \\ https://avatars.dicebear.com/styles adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral","title":"Styles"},{"location":"docs/#base-options","text":"All the possible options for the avatar. These options work for all the styles. seed (type: str ) - the seed for the avatar generator, determine its basic looks dataUri (type: bool ) - whether to give the dataUri (default False) flip (type: bool ) - flips the image vertically (default False) rotate (type: int ) - rotates the avatar (default 0, min 0, max 360) scale (type: int ) - the scale of the avatar drawing itself (default 100, min 0, max 200) radius (type: int ) - the radius of the avatar (default 0, min 0, max 50) size (type: int ) - the size of the avatar (px) (default 256, min 1, max 256) backgroundColor (type: DColor( \" #ffffff \" ) ) - the background color of the avatar (default white) translateX (type: int ) - move the avatar horizontally (default 0, min -100, max 100) translateY (type: int ) - move the avatar vertically (default 0, min -100, max 100)","title":"Base Options"},{"location":"docs/#specific-style-options","text":"Specific options to get a more detailed avatar. This is different for every style. \\ Click the style to see its options. adventurer adventurer-neutral avataaars big-ears big-ears-neutral big-smile bottts croodles croodles-neutral identicon initials micah miniavs open-peeps personas pixel-art pixel-art-neutral","title":"Specific Style Options"},{"location":"docs/#formats","text":"These are the only supported formats. \\ If you have Pillow (PIL) installed you can convert DAvatar to a PIL.Image.Image object to get a wider range of formats (Pillow doesn't support svg). DFormat.png DFormat.svg","title":"Formats"},{"location":"docs/#credits","text":"Special thanks to DiceBear ( Florian K\u00f6rner ) for making this amazing API and to all artists that helped making avatars!","title":"Credits"},{"location":"docs/#licenses-and-privacy-policy","text":"Dicebear Licenses : https://avatars.dicebear.com/licenses Dicebear Privacy Policy : https://avatars.dicebear.com/legal/privacy-policy Dicebear Python API wrapper (this project): https://github.com/jvherck/dicebear/blob/main/LICENSE","title":"Licenses and privacy policy"},{"location":"reference/dicebear/","text":"Module dicebear None None View Source # MIT License # # Copyright ( c ) 2022 jvherck ( https : // jvherck . github . io / dicebear / ) # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \" Software \" ) , to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . from . errors import * from . models import * from . avatar import * __version__ = \" 0.4.11 \" Sub-modules dicebear.avatar dicebear.errors dicebear.models Variables ascii_lowercase default_options digits options styles styles_depricated","title":"Index"},{"location":"reference/dicebear/#module-dicebear","text":"None None View Source # MIT License # # Copyright ( c ) 2022 jvherck ( https : // jvherck . github . io / dicebear / ) # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \" Software \" ) , to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . from . errors import * from . models import * from . avatar import * __version__ = \" 0.4.11 \"","title":"Module dicebear"},{"location":"reference/dicebear/#sub-modules","text":"dicebear.avatar dicebear.errors dicebear.models","title":"Sub-modules"},{"location":"reference/dicebear/#variables","text":"ascii_lowercase default_options digits options styles styles_depricated","title":"Variables"},{"location":"reference/dicebear/avatar/","text":"Module dicebear.avatar None None View Source # MIT License # # Copyright (c) 2022 jvherck (https://jvherck.github.io/dicebear/) # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE. import modulefinder from typing import overload import requests as r from urllib . parse import quote import os import pathlib import io from ast import literal_eval from . errors import * from . models import * try : from PIL import Image as i except Exception : class i : class Image : pass FindPil . found = False _url = \"https://avatars.dicebear.com/api/{}/{}.png?\" class DAvatar : default_options : dict = default_options all_options : list = options def __init__ ( self , style : DStyle , seed : str = None , * , options : DOptions = None , specific_options : dict = None ) -> None : \"\"\" Create an avatar using this class, use `.url_svg` to get the svg url or `.url_png` to get the png url. Clickable links: https://github.com/jvherck/dicebear#styles , https://github.com/jvherck/dicebear#base-options , https://github.com/jvherck/dicebear#specific-style-options :param style: the style of avatar you want to create; check the whole list at https://github.com/jvherck/dicebear#styles :param seed: the seed for the avatar; the avatar will be edited according to the seed. :param options: `class: DOptions` the options for the avatar; check the whole list at https://github.com/jvherck/dicebear#base-options :param specific_options: `class: dict` specific options for the specified avatar style; see all specific options at https://github.com/jvherck/dicebear#specific-style-options \"\"\" if specific_options is None : specific_options = {} if options is None : options = DOptions . empty if style not in styles : raise Error ( \"Invalid Style\" , '\"{}\" is not a valid style! Use `DStyle.list` to see all available styles' . format ( style )) self . __style : DStyle = style self . __seed : str = seed self . __options : DOptions = options self . __specific : dict = specific_options self . __url_svg : str = None self . __text : str = None self . __url_png : str = None self . __content : bytes = None self . __bytes : io . BytesIO = None self . __get_avatar_url () @ property def style ( self ) -> DStyle : \"\"\" :return: the style of the avatar \"\"\" return self . __style @ property def seed ( self ) -> str : \"\"\" :return: the seed of the avatar \"\"\" return self . __seed @ property def options ( self ) -> DOptions : \"\"\" :return: the options of the avatar \"\"\" _option_list = {} for key in self . __options : if self . __options [ key ] != DAvatar . default_options [ key ]: _option_list . update ({ key : self . __options [ key ]}) return DOptions ( fromdict = _option_list ) @ property def url_svg ( self ) -> str : \"\"\" :return: url to avatar (svg, use `.to_png()` to convert to png) \"\"\" return self . __url_svg @ property def url_png ( self ) -> str : \"\"\" :return: url to avatar (png, use `.url_svg` to convert to svg) \"\"\" return self . __url_png @ property def text ( self ) -> str : \"\"\" :return: returns the bytes of this request in str format \"\"\" return self . __text def __repr__ ( self ): self . __get_avatar_url () return self . text def __str__ ( self ) -> str : self . __get_avatar_url () return self . __url_png def __eq__ ( self , other ): return self . __url_png == other . __url_png def __ne__ ( self , other ): return self . __url_png != other . __url_png def __len__ ( self ): return len ( self . __options ) def __get_avatar_url ( self ) -> None : _link = _url _options = [] for item in options : if item == \"size\" and \"size\" in self . __options and self . __options [ \"size\" ] == 0 : continue elif item == \"size\" and \"size\" not in self . __options : continue elif item in self . __options and self . __options [ item ] == default_options [ item ]: continue elif item not in self . __options : continue else : _options . append ( \"{}={}\" . format ( quote ( item ), str ( self . __options [ item ]) . lower () if type ( self . __options [ item ]) == bool else quote ( str ( self . __options [ item ])) ) ) _specoptions = [] for item in self . __specific : _specoptions . append ( \"{}={}\" . format ( quote ( item ), str ( self . __specific [ item ]) . lower () if type ( self . __specific [ item ]) == bool else quote ( str ( self . __specific [ item ])) ) ) _link += \"&\" . join ( _options ) if len ( _options ) == 0 and len ( _specoptions ) > 0 : _link += \"&\" . join ( _specoptions ) else : _link += \"&\" + \"&\" . join ( _specoptions ) _link . replace ( \"False\" , \"false\" ) . replace ( \"True\" , \"true\" ) _link = _link . format ( quote ( str ( self . __style )), quote ( self . __seed ) if self . __seed is not None else \"\" ) req = r . request ( 'GET' , _link ) status = \"\" try : status = literal_eval ( req . text ) except ValueError : pass if type ( status ) == dict and \"statusCode\" in status : raise HTTPError ( status ) self . __url_png = req . url self . __url_svg = self . to_svg () self . __text = req . text self . __content = req . content self . __response : r . Response = req self . __bytes = io . BytesIO ( req . content ) @ staticmethod def __uniquify ( path ) -> str : filename , extension = os . path . splitext ( path ) counter = 1 while os . path . exists ( path ): path = filename + \"(\" + str ( counter ) + \")\" + extension counter += 1 return path def edit ( self , * , style : DStyle = None , seed : str = None , extra_options : DOptions = None , blank_options : DOptions = None ) -> str : \"\"\" Edit an already existing avatar. :param style: edit the avatar's style (style of drawing) :param seed: edit the avatar's seed (string to determine its looks) :param extra_options: edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if style : self . __style = style if seed : self . __seed = seed if extra_options : self . __options . update ( extra_options ) elif blank_options : self . __options = blank_options self . __get_avatar_url () return self . __url_png def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str : \"\"\" Edit the specific options for an already existing avatar. :param extra_options: edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old specific options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if extra_options : self . __specific . update ( extra_options ) elif blank_options : self . __specific = blank_options self . __get_avatar_url () return self . __url_png def to_png ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_png = self . __url_svg . replace ( \".svg\" , \".png\" ) return self . __url_png def to_svg ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_svg = self . __url_png . replace ( \".png\" , \".svg\" ) return self . __url_svg def save ( self , * , location : pathlib . Path = None , file_name : str = \"dicebear_avatar\" , format : DFormat = DFormat . png ) -> str : \"\"\" Save a file to your device. :param location: class `pathlib.Path` :: the folder to save the file in. (default is None which saves it in the current directory `os.getcwd()` :param file_name: class `str` :: the name of the file to save. (default is \"dicebear_avatar\") :param format: class `DFormat` :: the format of the file. (default is \"png\") :return: class `str` :: the path when successful \"\"\" if format not in DFormat . all_formats : s = f '\"{format}\" is not a supported format!' raise ImageError ( s ) if location is None : location = pathlib . Path ( os . getcwd ()) _location = os . path . join ( location , \"{}.{}\" . format ( file_name , format )) _location = self . __uniquify ( _location ) if format == DFormat . svg : svg_text = r . request ( 'GET' , self . to_svg ()) . text else : img = io . BytesIO ( self . __response . content ) # img = Image.open(io.BytesIO(self.__response.content)) ret = - 1 try : if format == DFormat . svg : with open ( _location , \"w\" , encoding = \"UTF-8\" ) as f : f . write ( svg_text ) f . close () else : with open ( _location , \"wb\" ) as f : f . write ( img . read ()) f . close () # img.save(_location, format) except ValueError : raise ImageValueError () except OSError : raise ImageOSError () except Exception as e : raise e else : ret = _location return ret @ pilcheck def pillow ( self ) -> i . Image : \"\"\" Convert a DAvatar to a :py:class:`PIL.Image.Image` object. :return: :py:class:`PIL.Image.Image` :raise :py:class:`dicebear_cli.errors.PILError`: \"\"\" raw_img = i . open ( self . __bytes ) . tobytes () img = i . frombytes ( \"RGBA\" , ( 256 , 256 ), raw_img ) return img # @pilcheck # def transparent(self) -> i.Image: # req = r.request(\"GET\", self.url_svg) # _svg = req.text.replace('<rect fill=\"#000000\" width=\"762\" height=\"762\" x=\"0\" y=\"0\"/>', '') # self.__bytes = io.BytesIO(bytes(_svg, \"UTF-8\")) # img = self.pillow() # return img Variables ascii_lowercase default_options digits options styles styles_depricated Classes DAvatar class DAvatar ( style : dicebear . models . DStyle , seed : str = None , * , options : dicebear . models . DOptions = None , specific_options : dict = None ) View Source class DAvatar : default_options : dict = default_options all_options : list = options def __init__ ( self , style : DStyle , seed : str = None , * , options : DOptions = None , specific_options : dict = None ) -> None : \"\"\" Create an avatar using this class, use `.url_svg` to get the svg url or `.url_png` to get the png url. Clickable links: https://github.com/jvherck/dicebear#styles , https://github.com/jvherck/dicebear#base-options , https://github.com/jvherck/dicebear#specific-style-options :param style: the style of avatar you want to create; check the whole list at https://github.com/jvherck/dicebear#styles :param seed: the seed for the avatar; the avatar will be edited according to the seed. :param options: `class: DOptions` the options for the avatar; check the whole list at https://github.com/jvherck/dicebear#base-options :param specific_options: `class: dict` specific options for the specified avatar style; see all specific options at https://github.com/jvherck/dicebear#specific-style-options \"\"\" if specific_options is None : specific_options = {} if options is None : options = DOptions . empty if style not in styles : raise Error ( \"Invalid Style\" , '\"{}\" is not a valid style! Use `DStyle.list` to see all available styles' . format ( style )) self . __style : DStyle = style self . __seed : str = seed self . __options : DOptions = options self . __specific : dict = specific_options self . __url_svg : str = None self . __text : str = None self . __url_png : str = None self . __content : bytes = None self . __bytes : io . BytesIO = None self . __get_avatar_url () @property def style ( self ) -> DStyle : \"\"\" :return: the style of the avatar \"\"\" return self . __style @property def seed ( self ) -> str : \"\"\" :return: the seed of the avatar \"\"\" return self . __seed @property def options ( self ) -> DOptions : \"\"\" :return: the options of the avatar \"\"\" _option_list = {} for key in self . __options : if self . __options [ key ] != DAvatar . default_options [ key ] : _option_list . update ( { key : self . __options [ key ] } ) return DOptions ( fromdict = _option_list ) @property def url_svg ( self ) -> str : \"\"\" :return: url to avatar (svg, use `.to_png()` to convert to png) \"\"\" return self . __url_svg @property def url_png ( self ) -> str : \"\"\" :return: url to avatar (png, use `.url_svg` to convert to svg) \"\"\" return self . __url_png @property def text ( self ) -> str : \"\"\" :return: returns the bytes of this request in str format \"\"\" return self . __text def __repr__ ( self ) : self . __get_avatar_url () return self . text def __str__ ( self ) -> str : self . __get_avatar_url () return self . __url_png def __eq__ ( self , other ) : return self . __url_png == other . __url_png def __ne__ ( self , other ) : return self . __url_png != other . __url_png def __len__ ( self ) : return len ( self . __options ) def __get_avatar_url ( self ) -> None : _link = _url _options = [] for item in options : if item == \"size\" and \"size\" in self . __options and self . __options [ \"size\" ] == 0 : continue elif item == \"size\" and \"size\" not in self . __options : continue elif item in self . __options and self . __options [ item ] == default_options [ item ] : continue elif item not in self . __options : continue else : _options . append ( \"{}={}\" . format ( quote ( item ), str ( self . __options [ item ] ). lower () if type ( self . __options [ item ] ) == bool else quote ( str ( self . __options [ item ] )) ) ) _specoptions = [] for item in self . __specific : _specoptions . append ( \"{}={}\" . format ( quote ( item ), str ( self . __specific [ item ] ). lower () if type ( self . __specific [ item ] ) == bool else quote ( str ( self . __specific [ item ] )) ) ) _link += \"&\" . join ( _options ) if len ( _options ) == 0 and len ( _specoptions ) > 0 : _link += \"&\" . join ( _specoptions ) else : _link += \"&\" + \"&\" . join ( _specoptions ) _link . replace ( \"False\" , \"false\" ). replace ( \"True\" , \"true\" ) _link = _link . format ( quote ( str ( self . __style )), quote ( self . __seed ) if self . __seed is not None else \"\" ) req = r . request ( 'GET' , _link ) status = \"\" try : status = literal_eval ( req . text ) except ValueError : pass if type ( status ) == dict and \"statusCode\" in status : raise HTTPError ( status ) self . __url_png = req . url self . __url_svg = self . to_svg () self . __text = req . text self . __content = req . content self . __response : r . Response = req self . __bytes = io . BytesIO ( req . content ) @staticmethod def __uniquify ( path ) -> str : filename , extension = os . path . splitext ( path ) counter = 1 while os . path . exists ( path ) : path = filename + \"(\" + str ( counter ) + \")\" + extension counter += 1 return path def edit ( self , * , style : DStyle = None , seed : str = None , extra_options : DOptions = None , blank_options : DOptions = None ) -> str : \"\"\" Edit an already existing avatar. :param style: edit the avatar's style (style of drawing) :param seed: edit the avatar's seed (string to determine its looks) :param extra_options: edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if style : self . __style = style if seed : self . __seed = seed if extra_options : self . __options . update ( extra_options ) elif blank_options : self . __options = blank_options self . __get_avatar_url () return self . __url_png def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str : \"\"\" Edit the specific options for an already existing avatar. :param extra_options: edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old specific options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if extra_options : self . __specific . update ( extra_options ) elif blank_options : self . __specific = blank_options self . __get_avatar_url () return self . __url_png def to_png ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_png = self . __url_svg . replace ( \".svg\" , \".png\" ) return self . __url_png def to_svg ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_svg = self . __url_png . replace ( \".png\" , \".svg\" ) return self . __url_svg def save ( self , * , location : pathlib . Path = None , file_name : str = \"dicebear_avatar\" , format : DFormat = DFormat . png ) -> str : \"\"\" Save a file to your device. :param location: class `pathlib.Path` :: the folder to save the file in. (default is None which saves it in the current directory `os.getcwd()` :param file_name: class `str` :: the name of the file to save. (default is \" dicebear_avatar \") :param format: class `DFormat` :: the format of the file. (default is \" png \") :return: class `str` :: the path when successful \"\"\" if format not in DFormat . all_formats : s = f '\"{format}\" is not a supported format!' raise ImageError ( s ) if location is None : location = pathlib . Path ( os . getcwd ()) _location = os . path . join ( location , \"{}.{}\" . format ( file_name , format )) _location = self . __uniquify ( _location ) if format == DFormat . svg : svg_text = r . request ( 'GET' , self . to_svg ()). text else : img = io . BytesIO ( self . __response . content ) # img = Image . open ( io . BytesIO ( self . __response . content )) ret = - 1 try : if format == DFormat . svg : with open ( _location , \"w\" , encoding = \"UTF-8\" ) as f : f . write ( svg_text ) f . close () else : with open ( _location , \"wb\" ) as f : f . write ( img . read ()) f . close () # img . save ( _location , format ) except ValueError : raise ImageValueError () except OSError : raise ImageOSError () except Exception as e : raise e else : ret = _location return ret @pilcheck def pillow ( self ) -> i . Image : \"\"\" Convert a DAvatar to a :py:class:`PIL.Image.Image` object. :return: :py:class:`PIL.Image.Image` :raise :py:class:`dicebear_cli.errors.PILError`: \"\"\" raw_img = i . open ( self . __bytes ). tobytes () img = i . frombytes ( \"RGBA\" , ( 256 , 256 ), raw_img ) return img # @pilcheck # def transparent ( self ) -> i . Image : # req = r . request ( \"GET\" , self . url_svg ) # _svg = req . text . replace ( '<rect fill=\"#000000\" width=\"762\" height=\"762\" x=\"0\" y=\"0\"/>' , '' ) # self . __bytes = io . BytesIO ( bytes ( _svg , \"UTF-8\" )) # img = self . pillow () # return img Class variables all_options default_options Instance variables options seed style text url_png url_svg Methods edit def edit ( self , * , style : dicebear . models . DStyle = None , seed : str = None , extra_options : dicebear . models . DOptions = None , blank_options : dicebear . models . DOptions = None ) -> str Edit an already existing avatar. Parameters: Name Type Description Default style None edit the avatar's style (style of drawing) None seed None edit the avatar's seed (string to determine its looks) None extra_options None edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with blank_options ! None blank_options None reset old options and set these options as new ones (new options) -- cannot be used at the same with extra_options ! None Returns: Type Description None returns the link to the avatar url (png) View Source def edit ( self , * , style : DStyle = None , seed : str = None , extra_options : DOptions = None , blank_options : DOptions = None ) -> str : \" \"\" Edit an already existing avatar. :param style: edit the avatar's style (style of drawing) :param seed: edit the avatar's seed (string to determine its looks) :param extra_options: edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\" \" if style : self . __style = style if seed : self . __seed = seed if extra_options : self . __options . update ( extra_options ) elif blank_options : self . __options = blank_options self . __get_avatar_url () return self . __url_png edit_specific def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str Edit the specific options for an already existing avatar. Parameters: Name Type Description Default extra_options None edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with blank_options ! None blank_options None reset old specific options and set these options as new ones (new options) -- cannot be used at the same with extra_options ! None Returns: Type Description None returns the link to the avatar url (png) View Source def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str : \" \"\" Edit the specific options for an already existing avatar. :param extra_options: edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old specific options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\" \" if extra_options : self . __specific . update ( extra_options ) elif blank_options : self . __specific = blank_options self . __get_avatar_url () return self . __url_png pillow def pillow ( * args , ** kwargs ) View Source def wrapper ( * args , ** kwargs ) : if FindPil . found is True : return func ( * args , ** kwargs ) else : log_error ( PILError ()) save def save ( self , * , location : pathlib . Path = None , file_name : str = 'dicebear_avatar' , format : dicebear . models . DFormat = 'png' ) -> str Save a file to your device. Parameters: Name Type Description Default location None class pathlib.Path :: the folder to save the file in. (default is None which saves it in the current directory os.getcwd() None file_name None class str :: the name of the file to save. (default is \"dicebear_avatar\") None format None class DFormat :: the format of the file. (default is \"png\") None Returns: Type Description None class str :: the path when successful View Source def save ( self , * , location : pathlib . Path = None , file_name : str = \"dicebear_avatar\" , format : DFormat = DFormat . png ) -> str : \" \"\" Save a file to your device. :param location: class `pathlib.Path` :: the folder to save the file in. (default is None which saves it in the current directory `os.getcwd()` :param file_name: class `str` :: the name of the file to save. (default is \" dicebear_avatar \") :param format: class `DFormat` :: the format of the file. (default is \" png \") :return: class `str` :: the path when successful \"\" \" if format not in DFormat . all_formats : s = f '\"{format}\" is not a supported format!' raise ImageError ( s ) if location is None : location = pathlib . Path ( os . getcwd ()) _location = os . path . join ( location , \"{}.{}\" . format ( file_name , format )) _location = self . __uniquify ( _location ) if format == DFormat . svg : svg_text = r . request ( 'GET' , self . to_svg ()). text else : img = io . BytesIO ( self . __response . content ) # img = Image.open(io.BytesIO(self.__response.content)) ret = - 1 try : if format == DFormat . svg : with open ( _location , \"w\" , encoding = \"UTF-8\" ) as f : f . write ( svg_text ) f . close () else : with open ( _location , \"wb\" ) as f : f . write ( img . read ()) f . close () # img.save(_location, format) except ValueError : raise ImageValueError () except OSError : raise ImageOSError () except Exception as e : raise e else : ret = _location return ret to_png def to_png ( self ) -> str Turns the avatar from svg into png and returns the url. Returns: Type Description None class str :: link to png avatar View Source def to_png ( self ) -> str : \" \"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\" \" self . __url_png = self . __url_svg . replace ( \".svg\" , \".png\" ) return self . __url_png to_svg def to_svg ( self ) -> str Turns the avatar from svg into png and returns the url. Returns: Type Description None class str :: link to png avatar View Source def to_svg ( self ) -> str : \" \"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\" \" self . __url_svg = self . __url_png . replace ( \".png\" , \".svg\" ) return self . __url_svg","title":"Avatar"},{"location":"reference/dicebear/avatar/#module-dicebearavatar","text":"None None View Source # MIT License # # Copyright (c) 2022 jvherck (https://jvherck.github.io/dicebear/) # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE. import modulefinder from typing import overload import requests as r from urllib . parse import quote import os import pathlib import io from ast import literal_eval from . errors import * from . models import * try : from PIL import Image as i except Exception : class i : class Image : pass FindPil . found = False _url = \"https://avatars.dicebear.com/api/{}/{}.png?\" class DAvatar : default_options : dict = default_options all_options : list = options def __init__ ( self , style : DStyle , seed : str = None , * , options : DOptions = None , specific_options : dict = None ) -> None : \"\"\" Create an avatar using this class, use `.url_svg` to get the svg url or `.url_png` to get the png url. Clickable links: https://github.com/jvherck/dicebear#styles , https://github.com/jvherck/dicebear#base-options , https://github.com/jvherck/dicebear#specific-style-options :param style: the style of avatar you want to create; check the whole list at https://github.com/jvherck/dicebear#styles :param seed: the seed for the avatar; the avatar will be edited according to the seed. :param options: `class: DOptions` the options for the avatar; check the whole list at https://github.com/jvherck/dicebear#base-options :param specific_options: `class: dict` specific options for the specified avatar style; see all specific options at https://github.com/jvherck/dicebear#specific-style-options \"\"\" if specific_options is None : specific_options = {} if options is None : options = DOptions . empty if style not in styles : raise Error ( \"Invalid Style\" , '\"{}\" is not a valid style! Use `DStyle.list` to see all available styles' . format ( style )) self . __style : DStyle = style self . __seed : str = seed self . __options : DOptions = options self . __specific : dict = specific_options self . __url_svg : str = None self . __text : str = None self . __url_png : str = None self . __content : bytes = None self . __bytes : io . BytesIO = None self . __get_avatar_url () @ property def style ( self ) -> DStyle : \"\"\" :return: the style of the avatar \"\"\" return self . __style @ property def seed ( self ) -> str : \"\"\" :return: the seed of the avatar \"\"\" return self . __seed @ property def options ( self ) -> DOptions : \"\"\" :return: the options of the avatar \"\"\" _option_list = {} for key in self . __options : if self . __options [ key ] != DAvatar . default_options [ key ]: _option_list . update ({ key : self . __options [ key ]}) return DOptions ( fromdict = _option_list ) @ property def url_svg ( self ) -> str : \"\"\" :return: url to avatar (svg, use `.to_png()` to convert to png) \"\"\" return self . __url_svg @ property def url_png ( self ) -> str : \"\"\" :return: url to avatar (png, use `.url_svg` to convert to svg) \"\"\" return self . __url_png @ property def text ( self ) -> str : \"\"\" :return: returns the bytes of this request in str format \"\"\" return self . __text def __repr__ ( self ): self . __get_avatar_url () return self . text def __str__ ( self ) -> str : self . __get_avatar_url () return self . __url_png def __eq__ ( self , other ): return self . __url_png == other . __url_png def __ne__ ( self , other ): return self . __url_png != other . __url_png def __len__ ( self ): return len ( self . __options ) def __get_avatar_url ( self ) -> None : _link = _url _options = [] for item in options : if item == \"size\" and \"size\" in self . __options and self . __options [ \"size\" ] == 0 : continue elif item == \"size\" and \"size\" not in self . __options : continue elif item in self . __options and self . __options [ item ] == default_options [ item ]: continue elif item not in self . __options : continue else : _options . append ( \"{}={}\" . format ( quote ( item ), str ( self . __options [ item ]) . lower () if type ( self . __options [ item ]) == bool else quote ( str ( self . __options [ item ])) ) ) _specoptions = [] for item in self . __specific : _specoptions . append ( \"{}={}\" . format ( quote ( item ), str ( self . __specific [ item ]) . lower () if type ( self . __specific [ item ]) == bool else quote ( str ( self . __specific [ item ])) ) ) _link += \"&\" . join ( _options ) if len ( _options ) == 0 and len ( _specoptions ) > 0 : _link += \"&\" . join ( _specoptions ) else : _link += \"&\" + \"&\" . join ( _specoptions ) _link . replace ( \"False\" , \"false\" ) . replace ( \"True\" , \"true\" ) _link = _link . format ( quote ( str ( self . __style )), quote ( self . __seed ) if self . __seed is not None else \"\" ) req = r . request ( 'GET' , _link ) status = \"\" try : status = literal_eval ( req . text ) except ValueError : pass if type ( status ) == dict and \"statusCode\" in status : raise HTTPError ( status ) self . __url_png = req . url self . __url_svg = self . to_svg () self . __text = req . text self . __content = req . content self . __response : r . Response = req self . __bytes = io . BytesIO ( req . content ) @ staticmethod def __uniquify ( path ) -> str : filename , extension = os . path . splitext ( path ) counter = 1 while os . path . exists ( path ): path = filename + \"(\" + str ( counter ) + \")\" + extension counter += 1 return path def edit ( self , * , style : DStyle = None , seed : str = None , extra_options : DOptions = None , blank_options : DOptions = None ) -> str : \"\"\" Edit an already existing avatar. :param style: edit the avatar's style (style of drawing) :param seed: edit the avatar's seed (string to determine its looks) :param extra_options: edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if style : self . __style = style if seed : self . __seed = seed if extra_options : self . __options . update ( extra_options ) elif blank_options : self . __options = blank_options self . __get_avatar_url () return self . __url_png def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str : \"\"\" Edit the specific options for an already existing avatar. :param extra_options: edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old specific options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if extra_options : self . __specific . update ( extra_options ) elif blank_options : self . __specific = blank_options self . __get_avatar_url () return self . __url_png def to_png ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_png = self . __url_svg . replace ( \".svg\" , \".png\" ) return self . __url_png def to_svg ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_svg = self . __url_png . replace ( \".png\" , \".svg\" ) return self . __url_svg def save ( self , * , location : pathlib . Path = None , file_name : str = \"dicebear_avatar\" , format : DFormat = DFormat . png ) -> str : \"\"\" Save a file to your device. :param location: class `pathlib.Path` :: the folder to save the file in. (default is None which saves it in the current directory `os.getcwd()` :param file_name: class `str` :: the name of the file to save. (default is \"dicebear_avatar\") :param format: class `DFormat` :: the format of the file. (default is \"png\") :return: class `str` :: the path when successful \"\"\" if format not in DFormat . all_formats : s = f '\"{format}\" is not a supported format!' raise ImageError ( s ) if location is None : location = pathlib . Path ( os . getcwd ()) _location = os . path . join ( location , \"{}.{}\" . format ( file_name , format )) _location = self . __uniquify ( _location ) if format == DFormat . svg : svg_text = r . request ( 'GET' , self . to_svg ()) . text else : img = io . BytesIO ( self . __response . content ) # img = Image.open(io.BytesIO(self.__response.content)) ret = - 1 try : if format == DFormat . svg : with open ( _location , \"w\" , encoding = \"UTF-8\" ) as f : f . write ( svg_text ) f . close () else : with open ( _location , \"wb\" ) as f : f . write ( img . read ()) f . close () # img.save(_location, format) except ValueError : raise ImageValueError () except OSError : raise ImageOSError () except Exception as e : raise e else : ret = _location return ret @ pilcheck def pillow ( self ) -> i . Image : \"\"\" Convert a DAvatar to a :py:class:`PIL.Image.Image` object. :return: :py:class:`PIL.Image.Image` :raise :py:class:`dicebear_cli.errors.PILError`: \"\"\" raw_img = i . open ( self . __bytes ) . tobytes () img = i . frombytes ( \"RGBA\" , ( 256 , 256 ), raw_img ) return img # @pilcheck # def transparent(self) -> i.Image: # req = r.request(\"GET\", self.url_svg) # _svg = req.text.replace('<rect fill=\"#000000\" width=\"762\" height=\"762\" x=\"0\" y=\"0\"/>', '') # self.__bytes = io.BytesIO(bytes(_svg, \"UTF-8\")) # img = self.pillow() # return img","title":"Module dicebear.avatar"},{"location":"reference/dicebear/avatar/#variables","text":"ascii_lowercase default_options digits options styles styles_depricated","title":"Variables"},{"location":"reference/dicebear/avatar/#classes","text":"","title":"Classes"},{"location":"reference/dicebear/avatar/#davatar","text":"class DAvatar ( style : dicebear . models . DStyle , seed : str = None , * , options : dicebear . models . DOptions = None , specific_options : dict = None ) View Source class DAvatar : default_options : dict = default_options all_options : list = options def __init__ ( self , style : DStyle , seed : str = None , * , options : DOptions = None , specific_options : dict = None ) -> None : \"\"\" Create an avatar using this class, use `.url_svg` to get the svg url or `.url_png` to get the png url. Clickable links: https://github.com/jvherck/dicebear#styles , https://github.com/jvherck/dicebear#base-options , https://github.com/jvherck/dicebear#specific-style-options :param style: the style of avatar you want to create; check the whole list at https://github.com/jvherck/dicebear#styles :param seed: the seed for the avatar; the avatar will be edited according to the seed. :param options: `class: DOptions` the options for the avatar; check the whole list at https://github.com/jvherck/dicebear#base-options :param specific_options: `class: dict` specific options for the specified avatar style; see all specific options at https://github.com/jvherck/dicebear#specific-style-options \"\"\" if specific_options is None : specific_options = {} if options is None : options = DOptions . empty if style not in styles : raise Error ( \"Invalid Style\" , '\"{}\" is not a valid style! Use `DStyle.list` to see all available styles' . format ( style )) self . __style : DStyle = style self . __seed : str = seed self . __options : DOptions = options self . __specific : dict = specific_options self . __url_svg : str = None self . __text : str = None self . __url_png : str = None self . __content : bytes = None self . __bytes : io . BytesIO = None self . __get_avatar_url () @property def style ( self ) -> DStyle : \"\"\" :return: the style of the avatar \"\"\" return self . __style @property def seed ( self ) -> str : \"\"\" :return: the seed of the avatar \"\"\" return self . __seed @property def options ( self ) -> DOptions : \"\"\" :return: the options of the avatar \"\"\" _option_list = {} for key in self . __options : if self . __options [ key ] != DAvatar . default_options [ key ] : _option_list . update ( { key : self . __options [ key ] } ) return DOptions ( fromdict = _option_list ) @property def url_svg ( self ) -> str : \"\"\" :return: url to avatar (svg, use `.to_png()` to convert to png) \"\"\" return self . __url_svg @property def url_png ( self ) -> str : \"\"\" :return: url to avatar (png, use `.url_svg` to convert to svg) \"\"\" return self . __url_png @property def text ( self ) -> str : \"\"\" :return: returns the bytes of this request in str format \"\"\" return self . __text def __repr__ ( self ) : self . __get_avatar_url () return self . text def __str__ ( self ) -> str : self . __get_avatar_url () return self . __url_png def __eq__ ( self , other ) : return self . __url_png == other . __url_png def __ne__ ( self , other ) : return self . __url_png != other . __url_png def __len__ ( self ) : return len ( self . __options ) def __get_avatar_url ( self ) -> None : _link = _url _options = [] for item in options : if item == \"size\" and \"size\" in self . __options and self . __options [ \"size\" ] == 0 : continue elif item == \"size\" and \"size\" not in self . __options : continue elif item in self . __options and self . __options [ item ] == default_options [ item ] : continue elif item not in self . __options : continue else : _options . append ( \"{}={}\" . format ( quote ( item ), str ( self . __options [ item ] ). lower () if type ( self . __options [ item ] ) == bool else quote ( str ( self . __options [ item ] )) ) ) _specoptions = [] for item in self . __specific : _specoptions . append ( \"{}={}\" . format ( quote ( item ), str ( self . __specific [ item ] ). lower () if type ( self . __specific [ item ] ) == bool else quote ( str ( self . __specific [ item ] )) ) ) _link += \"&\" . join ( _options ) if len ( _options ) == 0 and len ( _specoptions ) > 0 : _link += \"&\" . join ( _specoptions ) else : _link += \"&\" + \"&\" . join ( _specoptions ) _link . replace ( \"False\" , \"false\" ). replace ( \"True\" , \"true\" ) _link = _link . format ( quote ( str ( self . __style )), quote ( self . __seed ) if self . __seed is not None else \"\" ) req = r . request ( 'GET' , _link ) status = \"\" try : status = literal_eval ( req . text ) except ValueError : pass if type ( status ) == dict and \"statusCode\" in status : raise HTTPError ( status ) self . __url_png = req . url self . __url_svg = self . to_svg () self . __text = req . text self . __content = req . content self . __response : r . Response = req self . __bytes = io . BytesIO ( req . content ) @staticmethod def __uniquify ( path ) -> str : filename , extension = os . path . splitext ( path ) counter = 1 while os . path . exists ( path ) : path = filename + \"(\" + str ( counter ) + \")\" + extension counter += 1 return path def edit ( self , * , style : DStyle = None , seed : str = None , extra_options : DOptions = None , blank_options : DOptions = None ) -> str : \"\"\" Edit an already existing avatar. :param style: edit the avatar's style (style of drawing) :param seed: edit the avatar's seed (string to determine its looks) :param extra_options: edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if style : self . __style = style if seed : self . __seed = seed if extra_options : self . __options . update ( extra_options ) elif blank_options : self . __options = blank_options self . __get_avatar_url () return self . __url_png def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str : \"\"\" Edit the specific options for an already existing avatar. :param extra_options: edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old specific options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\"\" if extra_options : self . __specific . update ( extra_options ) elif blank_options : self . __specific = blank_options self . __get_avatar_url () return self . __url_png def to_png ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_png = self . __url_svg . replace ( \".svg\" , \".png\" ) return self . __url_png def to_svg ( self ) -> str : \"\"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\"\" self . __url_svg = self . __url_png . replace ( \".png\" , \".svg\" ) return self . __url_svg def save ( self , * , location : pathlib . Path = None , file_name : str = \"dicebear_avatar\" , format : DFormat = DFormat . png ) -> str : \"\"\" Save a file to your device. :param location: class `pathlib.Path` :: the folder to save the file in. (default is None which saves it in the current directory `os.getcwd()` :param file_name: class `str` :: the name of the file to save. (default is \" dicebear_avatar \") :param format: class `DFormat` :: the format of the file. (default is \" png \") :return: class `str` :: the path when successful \"\"\" if format not in DFormat . all_formats : s = f '\"{format}\" is not a supported format!' raise ImageError ( s ) if location is None : location = pathlib . Path ( os . getcwd ()) _location = os . path . join ( location , \"{}.{}\" . format ( file_name , format )) _location = self . __uniquify ( _location ) if format == DFormat . svg : svg_text = r . request ( 'GET' , self . to_svg ()). text else : img = io . BytesIO ( self . __response . content ) # img = Image . open ( io . BytesIO ( self . __response . content )) ret = - 1 try : if format == DFormat . svg : with open ( _location , \"w\" , encoding = \"UTF-8\" ) as f : f . write ( svg_text ) f . close () else : with open ( _location , \"wb\" ) as f : f . write ( img . read ()) f . close () # img . save ( _location , format ) except ValueError : raise ImageValueError () except OSError : raise ImageOSError () except Exception as e : raise e else : ret = _location return ret @pilcheck def pillow ( self ) -> i . Image : \"\"\" Convert a DAvatar to a :py:class:`PIL.Image.Image` object. :return: :py:class:`PIL.Image.Image` :raise :py:class:`dicebear_cli.errors.PILError`: \"\"\" raw_img = i . open ( self . __bytes ). tobytes () img = i . frombytes ( \"RGBA\" , ( 256 , 256 ), raw_img ) return img # @pilcheck # def transparent ( self ) -> i . Image : # req = r . request ( \"GET\" , self . url_svg ) # _svg = req . text . replace ( '<rect fill=\"#000000\" width=\"762\" height=\"762\" x=\"0\" y=\"0\"/>' , '' ) # self . __bytes = io . BytesIO ( bytes ( _svg , \"UTF-8\" )) # img = self . pillow () # return img","title":"DAvatar"},{"location":"reference/dicebear/avatar/#class-variables","text":"all_options default_options","title":"Class variables"},{"location":"reference/dicebear/avatar/#instance-variables","text":"options seed style text url_png url_svg","title":"Instance variables"},{"location":"reference/dicebear/avatar/#methods","text":"","title":"Methods"},{"location":"reference/dicebear/avatar/#edit","text":"def edit ( self , * , style : dicebear . models . DStyle = None , seed : str = None , extra_options : dicebear . models . DOptions = None , blank_options : dicebear . models . DOptions = None ) -> str Edit an already existing avatar. Parameters: Name Type Description Default style None edit the avatar's style (style of drawing) None seed None edit the avatar's seed (string to determine its looks) None extra_options None edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with blank_options ! None blank_options None reset old options and set these options as new ones (new options) -- cannot be used at the same with extra_options ! None Returns: Type Description None returns the link to the avatar url (png) View Source def edit ( self , * , style : DStyle = None , seed : str = None , extra_options : DOptions = None , blank_options : DOptions = None ) -> str : \" \"\" Edit an already existing avatar. :param style: edit the avatar's style (style of drawing) :param seed: edit the avatar's seed (string to determine its looks) :param extra_options: edit the avatar's options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\" \" if style : self . __style = style if seed : self . __seed = seed if extra_options : self . __options . update ( extra_options ) elif blank_options : self . __options = blank_options self . __get_avatar_url () return self . __url_png","title":"edit"},{"location":"reference/dicebear/avatar/#edit_specific","text":"def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str Edit the specific options for an already existing avatar. Parameters: Name Type Description Default extra_options None edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with blank_options ! None blank_options None reset old specific options and set these options as new ones (new options) -- cannot be used at the same with extra_options ! None Returns: Type Description None returns the link to the avatar url (png) View Source def edit_specific ( self , * , extra_options : dict = None , blank_options : dict = None ) -> str : \" \"\" Edit the specific options for an already existing avatar. :param extra_options: edit the avatar's specific options (old options stay, these get added) -- cannot be used at the same time with `blank_options` ! :param blank_options: reset old specific options and set these options as new ones (new options) -- cannot be used at the same with `extra_options` ! :return: returns the link to the avatar url (png) \"\" \" if extra_options : self . __specific . update ( extra_options ) elif blank_options : self . __specific = blank_options self . __get_avatar_url () return self . __url_png","title":"edit_specific"},{"location":"reference/dicebear/avatar/#pillow","text":"def pillow ( * args , ** kwargs ) View Source def wrapper ( * args , ** kwargs ) : if FindPil . found is True : return func ( * args , ** kwargs ) else : log_error ( PILError ())","title":"pillow"},{"location":"reference/dicebear/avatar/#save","text":"def save ( self , * , location : pathlib . Path = None , file_name : str = 'dicebear_avatar' , format : dicebear . models . DFormat = 'png' ) -> str Save a file to your device. Parameters: Name Type Description Default location None class pathlib.Path :: the folder to save the file in. (default is None which saves it in the current directory os.getcwd() None file_name None class str :: the name of the file to save. (default is \"dicebear_avatar\") None format None class DFormat :: the format of the file. (default is \"png\") None Returns: Type Description None class str :: the path when successful View Source def save ( self , * , location : pathlib . Path = None , file_name : str = \"dicebear_avatar\" , format : DFormat = DFormat . png ) -> str : \" \"\" Save a file to your device. :param location: class `pathlib.Path` :: the folder to save the file in. (default is None which saves it in the current directory `os.getcwd()` :param file_name: class `str` :: the name of the file to save. (default is \" dicebear_avatar \") :param format: class `DFormat` :: the format of the file. (default is \" png \") :return: class `str` :: the path when successful \"\" \" if format not in DFormat . all_formats : s = f '\"{format}\" is not a supported format!' raise ImageError ( s ) if location is None : location = pathlib . Path ( os . getcwd ()) _location = os . path . join ( location , \"{}.{}\" . format ( file_name , format )) _location = self . __uniquify ( _location ) if format == DFormat . svg : svg_text = r . request ( 'GET' , self . to_svg ()). text else : img = io . BytesIO ( self . __response . content ) # img = Image.open(io.BytesIO(self.__response.content)) ret = - 1 try : if format == DFormat . svg : with open ( _location , \"w\" , encoding = \"UTF-8\" ) as f : f . write ( svg_text ) f . close () else : with open ( _location , \"wb\" ) as f : f . write ( img . read ()) f . close () # img.save(_location, format) except ValueError : raise ImageValueError () except OSError : raise ImageOSError () except Exception as e : raise e else : ret = _location return ret","title":"save"},{"location":"reference/dicebear/avatar/#to_png","text":"def to_png ( self ) -> str Turns the avatar from svg into png and returns the url. Returns: Type Description None class str :: link to png avatar View Source def to_png ( self ) -> str : \" \"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\" \" self . __url_png = self . __url_svg . replace ( \".svg\" , \".png\" ) return self . __url_png","title":"to_png"},{"location":"reference/dicebear/avatar/#to_svg","text":"def to_svg ( self ) -> str Turns the avatar from svg into png and returns the url. Returns: Type Description None class str :: link to png avatar View Source def to_svg ( self ) -> str : \" \"\" Turns the avatar from svg into png and returns the url. :return: class `str` :: link to png avatar \"\" \" self . __url_svg = self . __url_png . replace ( \".png\" , \".svg\" ) return self . __url_svg","title":"to_svg"},{"location":"reference/dicebear/errors/","text":"Module dicebear.errors None None View Source # MIT License # # Copyright ( c ) 2022 jvherck ( https : // jvherck . github . io / dicebear / ) # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \" Software \" ) , to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . from typing import Union import logging class IncorrectColor ( Exception ) : def __init__ ( self , wrong_color : str = None ) : super () . __init__ ( ' Incorrect color given: \"{}\" is not an html hex code! (example: #ffffff) ' . format ( wrong_color )) class InvalidOption ( Exception ) : def __init__ ( self , wrong_option : str = None ) : super () . __init__ ( ' Invalid option given: \"{}\" is not an existing option! (use `Avatar.options` to get all possible options) ' . format ( wrong_option )) class Error ( Exception ) : def __init__ ( self , error_type : str = \"\" , message : str = \"\" ) : super () . __init__ ( ' {}{} ' . format ( error_type + ( ' : ' if error_type else '' ) , message )) class HTTPError ( Error ) : def __init__ ( self , dic : dict ) : super () . __init__ ( message = str ( dic )) class ImageError ( Exception ) : def __init__ ( self , message : str = None ) : super () . __init__ ( message ) class ImageValueError ( ImageError ) : def __init__ ( self , file_name : str = None ) : super () . __init__ ( ' The output format could not be determined from the file name (\"{}\") ' . format ( file_name )) class ImageOSError ( ImageError ) : def __init__ ( self , message : str = None ) : super () . __init__ ( ' The file could not be written. The file may have been created, and may contain partial data. (\"{}\") ' . format ( message )) class PILError ( ImageError ) : def __init__ ( self , message : str = \" To use this function you need to install Pillow. \" ) : super () . __init__ ( ' Module \"PIL (=Pillow)\" is not found! {} ' . format ( message )) def log_error ( exception : Exception | str ) : _exc = exception logger = logging . getLogger () logger . setLevel ( logging . ERROR ) handler = logging . StreamHandler () handler . setFormatter ( logging . Formatter ( f \" %(levelname)s: {_exc.__module__}: %(message)s \" )) handler . setLevel ( logging . ERROR ) logger . addHandler ( handler ) logger . error ( _exc ) Functions log_error def log_error ( exception : Exception | str ) View Source def log_error(exception: Exception | str): _exc = exception logger = logging.getLogger() logger.setLevel(logging.ERROR) handler = logging.StreamHandler() handler.setFormatter(logging.Formatter(f\"%(levelname)s: {_exc.__module__}: %(message)s\")) handler.setLevel(logging.ERROR) logger.addHandler(handler) logger.error(_exc) Classes Error class Error ( error_type : str = '' , message : str = '' ) View Source class Error ( Exception ): def __init__ ( self , error_type: str = \"\" , message: str = \"\" ): super (). __init__ ( '{}{}' . format ( error_type + ( ': ' if error_type else '' ), message )) Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants dicebear.errors.HTTPError Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. HTTPError class HTTPError ( dic : dict ) View Source class HTTPError ( Error ): def __init__ ( self , dic: dict ): super (). __init__ ( message = str ( dic )) Ancestors (in MRO) dicebear.errors.Error builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ImageError class ImageError ( message : str = None ) View Source class ImageError ( Exception ): def __init__ ( self , message: str = None ): super (). __init__ ( message ) Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants dicebear.errors.ImageValueError dicebear.errors.ImageOSError dicebear.errors.PILError Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ImageOSError class ImageOSError ( message : str = None ) View Source class ImageOSError ( ImageError ): def __init__ ( self , message: str = None ): super (). __init__ ( 'The file could not be written. The file may have been created, and may contain partial data. (\"{}\")' . format ( message )) Ancestors (in MRO) dicebear.errors.ImageError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ImageValueError class ImageValueError ( file_name : str = None ) View Source class ImageValueError ( ImageError ): def __init__ ( self , file_name: str = None ): super (). __init__ ( 'The output format could not be determined from the file name (\"{}\")' . format ( file_name )) Ancestors (in MRO) dicebear.errors.ImageError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. IncorrectColor class IncorrectColor ( wrong_color : str = None ) View Source class IncorrectColor ( Exception ): def __init__ ( self , wrong_color: str = None ): super (). __init__ ( 'Incorrect color given: \"{}\" is not an html hex code! (example: #ffffff)' . format ( wrong_color )) Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidOption class InvalidOption ( wrong_option : str = None ) View Source class InvalidOption ( Exception ): def __init__ ( self , wrong_option: str = None ): super (). __init__ ( 'Invalid option given: \"{}\" is not an existing option! (use `Avatar.options` to get all possible options)' . format ( wrong_option )) Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. PILError class PILError ( message : str = 'To use this function you need to install Pillow.' ) View Source class PILError ( ImageError ): def __init__ ( self , message: str = \"To use this function you need to install Pillow.\" ): super (). __init__ ( 'Module \"PIL (=Pillow)\" is not found! {}' . format ( message )) Ancestors (in MRO) dicebear.errors.ImageError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Errors"},{"location":"reference/dicebear/errors/#module-dicebearerrors","text":"None None View Source # MIT License # # Copyright ( c ) 2022 jvherck ( https : // jvherck . github . io / dicebear / ) # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \" Software \" ) , to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . from typing import Union import logging class IncorrectColor ( Exception ) : def __init__ ( self , wrong_color : str = None ) : super () . __init__ ( ' Incorrect color given: \"{}\" is not an html hex code! (example: #ffffff) ' . format ( wrong_color )) class InvalidOption ( Exception ) : def __init__ ( self , wrong_option : str = None ) : super () . __init__ ( ' Invalid option given: \"{}\" is not an existing option! (use `Avatar.options` to get all possible options) ' . format ( wrong_option )) class Error ( Exception ) : def __init__ ( self , error_type : str = \"\" , message : str = \"\" ) : super () . __init__ ( ' {}{} ' . format ( error_type + ( ' : ' if error_type else '' ) , message )) class HTTPError ( Error ) : def __init__ ( self , dic : dict ) : super () . __init__ ( message = str ( dic )) class ImageError ( Exception ) : def __init__ ( self , message : str = None ) : super () . __init__ ( message ) class ImageValueError ( ImageError ) : def __init__ ( self , file_name : str = None ) : super () . __init__ ( ' The output format could not be determined from the file name (\"{}\") ' . format ( file_name )) class ImageOSError ( ImageError ) : def __init__ ( self , message : str = None ) : super () . __init__ ( ' The file could not be written. The file may have been created, and may contain partial data. (\"{}\") ' . format ( message )) class PILError ( ImageError ) : def __init__ ( self , message : str = \" To use this function you need to install Pillow. \" ) : super () . __init__ ( ' Module \"PIL (=Pillow)\" is not found! {} ' . format ( message )) def log_error ( exception : Exception | str ) : _exc = exception logger = logging . getLogger () logger . setLevel ( logging . ERROR ) handler = logging . StreamHandler () handler . setFormatter ( logging . Formatter ( f \" %(levelname)s: {_exc.__module__}: %(message)s \" )) handler . setLevel ( logging . ERROR ) logger . addHandler ( handler ) logger . error ( _exc )","title":"Module dicebear.errors"},{"location":"reference/dicebear/errors/#functions","text":"","title":"Functions"},{"location":"reference/dicebear/errors/#log_error","text":"def log_error ( exception : Exception | str ) View Source def log_error(exception: Exception | str): _exc = exception logger = logging.getLogger() logger.setLevel(logging.ERROR) handler = logging.StreamHandler() handler.setFormatter(logging.Formatter(f\"%(levelname)s: {_exc.__module__}: %(message)s\")) handler.setLevel(logging.ERROR) logger.addHandler(handler) logger.error(_exc)","title":"log_error"},{"location":"reference/dicebear/errors/#classes","text":"","title":"Classes"},{"location":"reference/dicebear/errors/#error","text":"class Error ( error_type : str = '' , message : str = '' ) View Source class Error ( Exception ): def __init__ ( self , error_type: str = \"\" , message: str = \"\" ): super (). __init__ ( '{}{}' . format ( error_type + ( ': ' if error_type else '' ), message ))","title":"Error"},{"location":"reference/dicebear/errors/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#descendants","text":"dicebear.errors.HTTPError","title":"Descendants"},{"location":"reference/dicebear/errors/#class-variables","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/errors/#httperror","text":"class HTTPError ( dic : dict ) View Source class HTTPError ( Error ): def __init__ ( self , dic: dict ): super (). __init__ ( message = str ( dic ))","title":"HTTPError"},{"location":"reference/dicebear/errors/#ancestors-in-mro_1","text":"dicebear.errors.Error builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods_1","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/errors/#imageerror","text":"class ImageError ( message : str = None ) View Source class ImageError ( Exception ): def __init__ ( self , message: str = None ): super (). __init__ ( message )","title":"ImageError"},{"location":"reference/dicebear/errors/#ancestors-in-mro_2","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#descendants_1","text":"dicebear.errors.ImageValueError dicebear.errors.ImageOSError dicebear.errors.PILError","title":"Descendants"},{"location":"reference/dicebear/errors/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods_2","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/errors/#imageoserror","text":"class ImageOSError ( message : str = None ) View Source class ImageOSError ( ImageError ): def __init__ ( self , message: str = None ): super (). __init__ ( 'The file could not be written. The file may have been created, and may contain partial data. (\"{}\")' . format ( message ))","title":"ImageOSError"},{"location":"reference/dicebear/errors/#ancestors-in-mro_3","text":"dicebear.errors.ImageError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#class-variables_3","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods_3","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/errors/#imagevalueerror","text":"class ImageValueError ( file_name : str = None ) View Source class ImageValueError ( ImageError ): def __init__ ( self , file_name: str = None ): super (). __init__ ( 'The output format could not be determined from the file name (\"{}\")' . format ( file_name ))","title":"ImageValueError"},{"location":"reference/dicebear/errors/#ancestors-in-mro_4","text":"dicebear.errors.ImageError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#class-variables_4","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods_4","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/errors/#incorrectcolor","text":"class IncorrectColor ( wrong_color : str = None ) View Source class IncorrectColor ( Exception ): def __init__ ( self , wrong_color: str = None ): super (). __init__ ( 'Incorrect color given: \"{}\" is not an html hex code! (example: #ffffff)' . format ( wrong_color ))","title":"IncorrectColor"},{"location":"reference/dicebear/errors/#ancestors-in-mro_5","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#class-variables_5","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods_5","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/errors/#invalidoption","text":"class InvalidOption ( wrong_option : str = None ) View Source class InvalidOption ( Exception ): def __init__ ( self , wrong_option: str = None ): super (). __init__ ( 'Invalid option given: \"{}\" is not an existing option! (use `Avatar.options` to get all possible options)' . format ( wrong_option ))","title":"InvalidOption"},{"location":"reference/dicebear/errors/#ancestors-in-mro_6","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#class-variables_6","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods_6","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback_6","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/errors/#pilerror","text":"class PILError ( message : str = 'To use this function you need to install Pillow.' ) View Source class PILError ( ImageError ): def __init__ ( self , message: str = \"To use this function you need to install Pillow.\" ): super (). __init__ ( 'Module \"PIL (=Pillow)\" is not found! {}' . format ( message ))","title":"PILError"},{"location":"reference/dicebear/errors/#ancestors-in-mro_7","text":"dicebear.errors.ImageError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/errors/#class-variables_7","text":"args","title":"Class variables"},{"location":"reference/dicebear/errors/#methods_7","text":"","title":"Methods"},{"location":"reference/dicebear/errors/#with_traceback_7","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dicebear/models/","text":"Module dicebear.models None None View Source # MIT License # # Copyright ( c ) 2022 jvherck ( https : // jvherck . github . io / dicebear / ) # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \"Software\" ), to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \"AS IS\" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . import sys import traceback from . errors import * from random import choice , choices from string import digits class FindPil : found : bool = True ascii_lowercase = \"abcdef\" options = [ \"dataUri\", \"flip\", \"rotate\", \"scale\", \"radius\", \"size\", \"backgroundColor\", \"translateX\", \"translateY\" ] styles = [ \"adventurer\", \"adventurer-neutral\", \"avataaars\", \"big-ears\", \"big-ears-neutral\", \"big-smile\", \"bottts\", \"croodles\", \"croodles-neutral\", \"identicon\", \"initials\", \"micah\", \"miniavs\", \"open-peeps\", \"personas\", \"pixel-art\", \"pixel-art-neutral\" ] styles_depricated = [ \"female\", \"gridy\", \"human\", \"jdenticon\", \"male\" ] class DColor : def __init__ ( self , html_code : str = \"#ffffff\" ) : \"\"\" Colors used in this package. This uses HTML color codes! :param html_code: the html color code to use as color \"\"\" if html_code in [ \"random\", \"rnd\" ] : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) if not html_code . startswith ( \"#\" ) : html_code = \"#\" + html_code if len ( html_code ) not in [ 4, 7 ] : raise IncorrectColor ( str ( html_code )) self . html_code : str = str ( html_code ) def __str__ ( self ) : return f \"{self.html_code}\" def __repr__ ( self ) : return f \"{self.html_code}\" @staticmethod def random () : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) return DColor ( html_code ) @staticmethod def transparent () : return class DStyle : \"\"\" All possible styles for the avatars. Visit https://avatars.dicebear.com/styles to see what they look like.\\n - Note: Only works with attributes! \"\"\" list = all_styles = styles adventurer = styles [ 0 ] adventurer_neutral = styles [ 1 ] avataaars = styles [ 2 ] big_ears = styles [ 3 ] big_ears_neutral = styles [ 4 ] big_smile = styles [ 5 ] bottts = styles [ 6 ] croodles = styles [ 7 ] croodles_neutral = styles [ 8 ] identicon = styles [ 9 ] initials = styles [ 10 ] micah = styles [ 11 ] miniavs = styles [ 12 ] open_peeps = styles [ 13 ] personas = styles [ 14 ] pixel_art = styles [ 15 ] pixel_art_neutral = styles [ 16 ] random = choice ( styles ) def __init__ ( self ) : \"\"\"Only use `.attribute` to use a style.\"\"\" pass @staticmethod def from_str ( style_str : str ) : \"\"\"Get an avatar style from a string\"\"\" return eval ( \"DStyle.{}\" . format ( style_str . replace ( \"-\" , \"_\" ))) class DFormat : \"\"\" All possible image formats for saving or converting avatars. - Note: Only works with attributes! \"\"\" list = all_formats = [ \"png\", \"svg\" ] png = \"png\" svg = \"svg\" def __init__ ( self ) : \"\"\"Only use `.attribute` to use a format.\"\"\" pass @staticmethod def from_str ( format_str : str ) : \"\"\"Get an avatar format from a string\"\"\" return eval ( \"DFormat.{}\" . format ( format_str )) default_options : dict = { options [ 0 ] : False , options [ 1 ] : False , options [ 2 ] : 0 , options [ 3 ] : 100 , options [ 4 ] : 0 , options [ 5 ] : 0 , options [ 6 ] : DColor (), options [ 7 ] : 0 , options [ 8 ] : 0 } class DOptions ( dict ) : empty : dict = {} def __init__ ( self , * , dataUri : bool = False , flip : bool = False , rotate : int = 0 , scale : int = 100 , radius : int = 0 , size : int = 0 , backgroundColor : DColor = DColor (), translateX : int = 0 , translateY : int = 0 , ** kwargs ) : \"\"\" Go to https://github.com/jvherck/dicebear#base-options to see all info :param kwargs: `fromdict` to use a custom dict instead of args (if you use this kwarg all other args will be neglected) \"\"\" # kwargs : list = [ dataUri, flip, rotate, scale, radius, size, backgroundColor, translateX, translateY ] dic = kwargs . get ( \"fromdict\" , {} ) current : dict = { \"dataUri\" : dataUri , \"flip\" : flip , \"rotate\" : rotate , \"scale\" : scale , \"radius\" : radius , \"size\" : size , \"backgroundColor\" : backgroundColor , \"translateX\" : translateX , \"translateY\" : translateY } if not dic : for item in current : if item in default_options and current [ item ] != default_options [ item ] : dic . update ( { item : current [ item ] } ) if \"size\" in dic and dic [ \"size\" ] == 0 : dic . pop ( \"size\" ) super (). __init__ ( dic ) def pilcheck ( func ) : def wrapper ( * args , ** kwargs ) : if FindPil . found is True : return func ( * args , ** kwargs ) else : log_error ( PILError ()) return wrapper Variables ascii_lowercase default_options digits options styles styles_depricated Functions pilcheck def pilcheck ( func ) View Source def pilcheck ( func ) : def wrapper ( * args , ** kwargs ) : if FindPil . found is True : return func ( * args , ** kwargs ) else : log_error ( PILError ()) return wrapper Classes DColor class DColor ( html_code : str = '#ffffff' ) View Source class DColor : def __init__ ( self , html_code : str = \"#ffffff\" ) : \"\"\" Colors used in this package. This uses HTML color codes! :param html_code: the html color code to use as color \"\"\" if html_code in [ \"random\", \"rnd\" ] : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) if not html_code . startswith ( \"#\" ) : html_code = \"#\" + html_code if len ( html_code ) not in [ 4, 7 ] : raise IncorrectColor ( str ( html_code )) self . html_code : str = str ( html_code ) def __str__ ( self ) : return f \"{self.html_code}\" def __repr__ ( self ) : return f \"{self.html_code}\" @staticmethod def random () : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) return DColor ( html_code ) @staticmethod def transparent () : return Static methods random def random ( ) View Source @staticmethod def random () : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) return DColor ( html_code ) transparent def transparent ( ) View Source @staticmethod def transparent () : return DFormat class DFormat ( ) View Source class DFormat : \"\"\" All possible image formats for saving or converting avatars. - Note: Only works with attributes! \"\"\" list = all_formats = [ \"png\", \"svg\" ] png = \"png\" svg = \"svg\" def __init__ ( self ) : \"\"\"Only use `.attribute` to use a format.\"\"\" pass @staticmethod def from_str ( format_str : str ) : \"\"\"Get an avatar format from a string\"\"\" return eval ( \"DFormat.{}\" . format ( format_str )) Class variables all_formats list png svg Static methods from_str def from_str ( format_str : str ) Get an avatar format from a string View Source @staticmethod def from_str ( format_str : str ) : \"\"\"Get an avatar format from a string\"\"\" return eval ( \"DFormat.{}\" . format ( format_str )) DOptions class DOptions ( * , dataUri : bool = False , flip : bool = False , rotate : int = 0 , scale : int = 100 , radius : int = 0 , size : int = 0 , backgroundColor : dicebear . models . DColor = #ffffff, translateX : int = 0 , translateY : int = 0 , ** kwargs ) View Source class DOptions ( dict ) : empty : dict = {} def __init__ ( self , * , dataUri : bool = False , flip : bool = False , rotate : int = 0 , scale : int = 100 , radius : int = 0 , size : int = 0 , backgroundColor : DColor = DColor (), translateX : int = 0 , translateY : int = 0 , ** kwargs ) : \"\"\" Go to https://github.com/jvherck/dicebear#base-options to see all info :param kwargs: `fromdict` to use a custom dict instead of args (if you use this kwarg all other args will be neglected) \"\"\" # kwargs : list = [ dataUri, flip, rotate, scale, radius, size, backgroundColor, translateX, translateY ] dic = kwargs . get ( \"fromdict\" , {} ) current : dict = { \"dataUri\" : dataUri , \"flip\" : flip , \"rotate\" : rotate , \"scale\" : scale , \"radius\" : radius , \"size\" : size , \"backgroundColor\" : backgroundColor , \"translateX\" : translateX , \"translateY\" : translateY } if not dic : for item in current : if item in default_options and current [ item ] != default_options [ item ] : dic . update ( { item : current [ item ] } ) if \"size\" in dic and dic [ \"size\" ] == 0 : dic . pop ( \"size\" ) super (). __init__ ( dic ) Ancestors (in MRO) builtins.dict Class variables empty Methods clear def clear ( ... ) D.clear() -> None. Remove all items from D. copy def copy ( ... ) D.copy() -> a shallow copy of D fromkeys def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items def items ( ... ) D.items() -> a set-like object providing a view on D's items keys def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError. popitem def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values def values ( ... ) D.values() -> an object providing a view on D's values DStyle class DStyle ( ) View Source class DStyle : \"\"\" All possible styles for the avatars. Visit https://avatars.dicebear.com/styles to see what they look like.\\n - Note: Only works with attributes! \"\"\" list = all_styles = styles adventurer = styles [ 0 ] adventurer_neutral = styles [ 1 ] avataaars = styles [ 2 ] big_ears = styles [ 3 ] big_ears_neutral = styles [ 4 ] big_smile = styles [ 5 ] bottts = styles [ 6 ] croodles = styles [ 7 ] croodles_neutral = styles [ 8 ] identicon = styles [ 9 ] initials = styles [ 10 ] micah = styles [ 11 ] miniavs = styles [ 12 ] open_peeps = styles [ 13 ] personas = styles [ 14 ] pixel_art = styles [ 15 ] pixel_art_neutral = styles [ 16 ] random = choice ( styles ) def __init__ ( self ) : \"\"\"Only use `.attribute` to use a style.\"\"\" pass @staticmethod def from_str ( style_str : str ) : \"\"\"Get an avatar style from a string\"\"\" return eval ( \"DStyle.{}\" . format ( style_str . replace ( \"-\" , \"_\" ))) Class variables adventurer adventurer_neutral all_styles avataaars big_ears big_ears_neutral big_smile bottts croodles croodles_neutral identicon initials list micah miniavs open_peeps personas pixel_art pixel_art_neutral random Static methods from_str def from_str ( style_str : str ) Get an avatar style from a string View Source @staticmethod def from_str ( style_str : str ) : \"\"\"Get an avatar style from a string\"\"\" return eval ( \"DStyle.{}\" . format ( style_str . replace ( \"-\" , \"_\" ))) FindPil class FindPil ( / , * args , ** kwargs ) View Source class FindPil: found: bool = True Class variables found","title":"Models"},{"location":"reference/dicebear/models/#module-dicebearmodels","text":"None None View Source # MIT License # # Copyright ( c ) 2022 jvherck ( https : // jvherck . github . io / dicebear / ) # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \"Software\" ), to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in all # copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \"AS IS\" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . import sys import traceback from . errors import * from random import choice , choices from string import digits class FindPil : found : bool = True ascii_lowercase = \"abcdef\" options = [ \"dataUri\", \"flip\", \"rotate\", \"scale\", \"radius\", \"size\", \"backgroundColor\", \"translateX\", \"translateY\" ] styles = [ \"adventurer\", \"adventurer-neutral\", \"avataaars\", \"big-ears\", \"big-ears-neutral\", \"big-smile\", \"bottts\", \"croodles\", \"croodles-neutral\", \"identicon\", \"initials\", \"micah\", \"miniavs\", \"open-peeps\", \"personas\", \"pixel-art\", \"pixel-art-neutral\" ] styles_depricated = [ \"female\", \"gridy\", \"human\", \"jdenticon\", \"male\" ] class DColor : def __init__ ( self , html_code : str = \"#ffffff\" ) : \"\"\" Colors used in this package. This uses HTML color codes! :param html_code: the html color code to use as color \"\"\" if html_code in [ \"random\", \"rnd\" ] : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) if not html_code . startswith ( \"#\" ) : html_code = \"#\" + html_code if len ( html_code ) not in [ 4, 7 ] : raise IncorrectColor ( str ( html_code )) self . html_code : str = str ( html_code ) def __str__ ( self ) : return f \"{self.html_code}\" def __repr__ ( self ) : return f \"{self.html_code}\" @staticmethod def random () : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) return DColor ( html_code ) @staticmethod def transparent () : return class DStyle : \"\"\" All possible styles for the avatars. Visit https://avatars.dicebear.com/styles to see what they look like.\\n - Note: Only works with attributes! \"\"\" list = all_styles = styles adventurer = styles [ 0 ] adventurer_neutral = styles [ 1 ] avataaars = styles [ 2 ] big_ears = styles [ 3 ] big_ears_neutral = styles [ 4 ] big_smile = styles [ 5 ] bottts = styles [ 6 ] croodles = styles [ 7 ] croodles_neutral = styles [ 8 ] identicon = styles [ 9 ] initials = styles [ 10 ] micah = styles [ 11 ] miniavs = styles [ 12 ] open_peeps = styles [ 13 ] personas = styles [ 14 ] pixel_art = styles [ 15 ] pixel_art_neutral = styles [ 16 ] random = choice ( styles ) def __init__ ( self ) : \"\"\"Only use `.attribute` to use a style.\"\"\" pass @staticmethod def from_str ( style_str : str ) : \"\"\"Get an avatar style from a string\"\"\" return eval ( \"DStyle.{}\" . format ( style_str . replace ( \"-\" , \"_\" ))) class DFormat : \"\"\" All possible image formats for saving or converting avatars. - Note: Only works with attributes! \"\"\" list = all_formats = [ \"png\", \"svg\" ] png = \"png\" svg = \"svg\" def __init__ ( self ) : \"\"\"Only use `.attribute` to use a format.\"\"\" pass @staticmethod def from_str ( format_str : str ) : \"\"\"Get an avatar format from a string\"\"\" return eval ( \"DFormat.{}\" . format ( format_str )) default_options : dict = { options [ 0 ] : False , options [ 1 ] : False , options [ 2 ] : 0 , options [ 3 ] : 100 , options [ 4 ] : 0 , options [ 5 ] : 0 , options [ 6 ] : DColor (), options [ 7 ] : 0 , options [ 8 ] : 0 } class DOptions ( dict ) : empty : dict = {} def __init__ ( self , * , dataUri : bool = False , flip : bool = False , rotate : int = 0 , scale : int = 100 , radius : int = 0 , size : int = 0 , backgroundColor : DColor = DColor (), translateX : int = 0 , translateY : int = 0 , ** kwargs ) : \"\"\" Go to https://github.com/jvherck/dicebear#base-options to see all info :param kwargs: `fromdict` to use a custom dict instead of args (if you use this kwarg all other args will be neglected) \"\"\" # kwargs : list = [ dataUri, flip, rotate, scale, radius, size, backgroundColor, translateX, translateY ] dic = kwargs . get ( \"fromdict\" , {} ) current : dict = { \"dataUri\" : dataUri , \"flip\" : flip , \"rotate\" : rotate , \"scale\" : scale , \"radius\" : radius , \"size\" : size , \"backgroundColor\" : backgroundColor , \"translateX\" : translateX , \"translateY\" : translateY } if not dic : for item in current : if item in default_options and current [ item ] != default_options [ item ] : dic . update ( { item : current [ item ] } ) if \"size\" in dic and dic [ \"size\" ] == 0 : dic . pop ( \"size\" ) super (). __init__ ( dic ) def pilcheck ( func ) : def wrapper ( * args , ** kwargs ) : if FindPil . found is True : return func ( * args , ** kwargs ) else : log_error ( PILError ()) return wrapper","title":"Module dicebear.models"},{"location":"reference/dicebear/models/#variables","text":"ascii_lowercase default_options digits options styles styles_depricated","title":"Variables"},{"location":"reference/dicebear/models/#functions","text":"","title":"Functions"},{"location":"reference/dicebear/models/#pilcheck","text":"def pilcheck ( func ) View Source def pilcheck ( func ) : def wrapper ( * args , ** kwargs ) : if FindPil . found is True : return func ( * args , ** kwargs ) else : log_error ( PILError ()) return wrapper","title":"pilcheck"},{"location":"reference/dicebear/models/#classes","text":"","title":"Classes"},{"location":"reference/dicebear/models/#dcolor","text":"class DColor ( html_code : str = '#ffffff' ) View Source class DColor : def __init__ ( self , html_code : str = \"#ffffff\" ) : \"\"\" Colors used in this package. This uses HTML color codes! :param html_code: the html color code to use as color \"\"\" if html_code in [ \"random\", \"rnd\" ] : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) if not html_code . startswith ( \"#\" ) : html_code = \"#\" + html_code if len ( html_code ) not in [ 4, 7 ] : raise IncorrectColor ( str ( html_code )) self . html_code : str = str ( html_code ) def __str__ ( self ) : return f \"{self.html_code}\" def __repr__ ( self ) : return f \"{self.html_code}\" @staticmethod def random () : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) return DColor ( html_code ) @staticmethod def transparent () : return","title":"DColor"},{"location":"reference/dicebear/models/#static-methods","text":"","title":"Static methods"},{"location":"reference/dicebear/models/#random","text":"def random ( ) View Source @staticmethod def random () : html_code = '#' + '' . join ( choices ( ascii_lowercase + digits , k = 6 )) return DColor ( html_code )","title":"random"},{"location":"reference/dicebear/models/#transparent","text":"def transparent ( ) View Source @staticmethod def transparent () : return","title":"transparent"},{"location":"reference/dicebear/models/#dformat","text":"class DFormat ( ) View Source class DFormat : \"\"\" All possible image formats for saving or converting avatars. - Note: Only works with attributes! \"\"\" list = all_formats = [ \"png\", \"svg\" ] png = \"png\" svg = \"svg\" def __init__ ( self ) : \"\"\"Only use `.attribute` to use a format.\"\"\" pass @staticmethod def from_str ( format_str : str ) : \"\"\"Get an avatar format from a string\"\"\" return eval ( \"DFormat.{}\" . format ( format_str ))","title":"DFormat"},{"location":"reference/dicebear/models/#class-variables","text":"all_formats list png svg","title":"Class variables"},{"location":"reference/dicebear/models/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/dicebear/models/#from_str","text":"def from_str ( format_str : str ) Get an avatar format from a string View Source @staticmethod def from_str ( format_str : str ) : \"\"\"Get an avatar format from a string\"\"\" return eval ( \"DFormat.{}\" . format ( format_str ))","title":"from_str"},{"location":"reference/dicebear/models/#doptions","text":"class DOptions ( * , dataUri : bool = False , flip : bool = False , rotate : int = 0 , scale : int = 100 , radius : int = 0 , size : int = 0 , backgroundColor : dicebear . models . DColor = #ffffff, translateX : int = 0 , translateY : int = 0 , ** kwargs ) View Source class DOptions ( dict ) : empty : dict = {} def __init__ ( self , * , dataUri : bool = False , flip : bool = False , rotate : int = 0 , scale : int = 100 , radius : int = 0 , size : int = 0 , backgroundColor : DColor = DColor (), translateX : int = 0 , translateY : int = 0 , ** kwargs ) : \"\"\" Go to https://github.com/jvherck/dicebear#base-options to see all info :param kwargs: `fromdict` to use a custom dict instead of args (if you use this kwarg all other args will be neglected) \"\"\" # kwargs : list = [ dataUri, flip, rotate, scale, radius, size, backgroundColor, translateX, translateY ] dic = kwargs . get ( \"fromdict\" , {} ) current : dict = { \"dataUri\" : dataUri , \"flip\" : flip , \"rotate\" : rotate , \"scale\" : scale , \"radius\" : radius , \"size\" : size , \"backgroundColor\" : backgroundColor , \"translateX\" : translateX , \"translateY\" : translateY } if not dic : for item in current : if item in default_options and current [ item ] != default_options [ item ] : dic . update ( { item : current [ item ] } ) if \"size\" in dic and dic [ \"size\" ] == 0 : dic . pop ( \"size\" ) super (). __init__ ( dic )","title":"DOptions"},{"location":"reference/dicebear/models/#ancestors-in-mro","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/dicebear/models/#class-variables_1","text":"empty","title":"Class variables"},{"location":"reference/dicebear/models/#methods","text":"","title":"Methods"},{"location":"reference/dicebear/models/#clear","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/dicebear/models/#copy","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/dicebear/models/#fromkeys","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/dicebear/models/#get","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/dicebear/models/#items","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/dicebear/models/#keys","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/dicebear/models/#pop","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError.","title":"pop"},{"location":"reference/dicebear/models/#popitem","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/dicebear/models/#setdefault","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/dicebear/models/#update","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/dicebear/models/#values","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"reference/dicebear/models/#dstyle","text":"class DStyle ( ) View Source class DStyle : \"\"\" All possible styles for the avatars. Visit https://avatars.dicebear.com/styles to see what they look like.\\n - Note: Only works with attributes! \"\"\" list = all_styles = styles adventurer = styles [ 0 ] adventurer_neutral = styles [ 1 ] avataaars = styles [ 2 ] big_ears = styles [ 3 ] big_ears_neutral = styles [ 4 ] big_smile = styles [ 5 ] bottts = styles [ 6 ] croodles = styles [ 7 ] croodles_neutral = styles [ 8 ] identicon = styles [ 9 ] initials = styles [ 10 ] micah = styles [ 11 ] miniavs = styles [ 12 ] open_peeps = styles [ 13 ] personas = styles [ 14 ] pixel_art = styles [ 15 ] pixel_art_neutral = styles [ 16 ] random = choice ( styles ) def __init__ ( self ) : \"\"\"Only use `.attribute` to use a style.\"\"\" pass @staticmethod def from_str ( style_str : str ) : \"\"\"Get an avatar style from a string\"\"\" return eval ( \"DStyle.{}\" . format ( style_str . replace ( \"-\" , \"_\" )))","title":"DStyle"},{"location":"reference/dicebear/models/#class-variables_2","text":"adventurer adventurer_neutral all_styles avataaars big_ears big_ears_neutral big_smile bottts croodles croodles_neutral identicon initials list micah miniavs open_peeps personas pixel_art pixel_art_neutral random","title":"Class variables"},{"location":"reference/dicebear/models/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/dicebear/models/#from_str_1","text":"def from_str ( style_str : str ) Get an avatar style from a string View Source @staticmethod def from_str ( style_str : str ) : \"\"\"Get an avatar style from a string\"\"\" return eval ( \"DStyle.{}\" . format ( style_str . replace ( \"-\" , \"_\" )))","title":"from_str"},{"location":"reference/dicebear/models/#findpil","text":"class FindPil ( / , * args , ** kwargs ) View Source class FindPil: found: bool = True","title":"FindPil"},{"location":"reference/dicebear/models/#class-variables_3","text":"found","title":"Class variables"}]}